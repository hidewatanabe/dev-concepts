# Prototype

## Intenção
Especificar os tipos de objetos a serem criados usando uma instância-protótipo e criar novos objetos pela cópia desse protótipo.

## Tipo
Criacional de objetos

## Motivação

## Aplicabilidade:
- Quando as classes a instnaciar forem especificadas em tempo de execução, por exemplo, por carga dinâmica;
- Para evitar a construção de uma hierarquia de classes de fábricas paralela à hierarquia de classes de produto;
- Quando as instâncias de uma classe puderem ter uma dentre poucas combinações diferentes de estados. Pode ser mais conveniente instalar um número correspondente de protótipos e cloná-los, ao invés de instanciar a classe manualmente, cada vez com um estado apropriado.

## Consequências:
- *Ele oculta as classes de produtos concretas do cliente.* Dessa forma, reduzindo o número de nomes que os clientes necessitam saber.
- *Possibilitam o uso de classes específicasde uma aplicação sem a necessidade de modificação.*
- *Acrescenta e remove produtos em tempo de execução.* **Protótipos** permitem incorporar uma nova classe concreta de produto a um sistema, simplesmente registrando una instância **protótipo** com o cliente. Isso é um pouco mais flexível do que outros padrões de criação, porque o cliente pode isntalar e remover **protótipos** em tempo de execução.
- *Especifica novos objetos para variação de valores.* Sistemas altamente dinâmicos permitem definir novos comportamentos através da composição de objetos - por exemplo, pela especificação de valores para as variáveis de um objeto - e não pela sua definição de novas classes. Você efetivamente define novos tipos de objetos pela isntanciação de classes existentes e registrando as instâncias como **protótipos** dos objetos-clientes. Um cliente pode exibir um novo comportamento através da delegação de responsabilildades para o **protótipo**. Esse tipo de projeto permite aos usuários definir novas "classes" sem ter que programar. De fato, clonar um **protótipo** é semelhante a instanciar uma classe. O padrão **Prototype** pode reduzir grandemente o número de classes que um sistema necessita.
- *Especifica novos objetos pela variação da estrutura.* Muitas aplicações constróem objetos com partes e subpartes. Por exemplo, editores para o projeto de circuitos que constróem circuitos a partir de subcircuitos. Por questões de conveniência, tias aplicações frequentemente permitem instanciar estruturas complexas, definidas pelo usuário, para, por exemplo, usar um subcircuito específico repetidas vezes. O padrão **Prototype** também suporta isso. Simplesmente adicionamos esse subcircuito como um **protótipo** à paleta dos elementos de circuitos disponíveis. Contanto que o objeto-circuito composto implemente um clone por replicação *(deep copy)*, circuitos com diferentes estruturas podem ser **protótipos**.
- *Reduz o número de subclasses.* O **Factory Method** frequentemente produz uma hierarquia de classes **Creator** paralela à hierarquia de classes do produto. O padrão **Prototype** permite clonar um protótipo em vez de pedir a um método-fábrica para construir um novo objeto. Daí não necessitar-se de nenhuma hierarquia de classes **Creator**. Esse benefício se aplica primariamente a linguagens que não tratamas classes como objetos de primeira classe. As linguagens que assim o fazem obtém menos benefícios, uma vez que sempre se usa um objeto-classe como um criador. Objetos-classe já funcionam como **protótipos** nessas linguagens.
- *Configura dinamicamente uma aplicação com classes.* Alguns ambientes de tempo de execução permitem carregar classes dinamicamente numa aplicação. O padrão **Prototype** é a chave para exploração de tais possibilidades numa linguagem como C++. Uma aplicação que quer criar instâncias de uma classe dinamicamente carregada não será capaz de referenciar o seu construtor estaticamente. Em vez disso, o ambiente de tempo de execução cria uma instância de cada classe automaticamente, quando carregada, e registra a instância junto a um gerenciador de **protótipo**. Então, a aplicação pode solicitar ao gerenciador de **protótipos** instânciasde classes recém-carregadas, classes essas que originalmente não estavam "linkadas"ao programa.
- *Ponto fraco.* O principal ponto fraco do padrão **Prototype** é que cada subclasse de **Prototype** deve implementar a operação Clone, o que pode ser difícil. Por exemplo, acrescentar Clone é difícil quando as classes consideradas já existem. A implementação de Clone pode ser complicada quando uma estrutura interna dessas classes inclui objetos que não suportam operação de cópia ou term referências circulares.